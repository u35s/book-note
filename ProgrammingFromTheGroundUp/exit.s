# 在汇编程序中,任何以小数点(.)开始的指令都不会被直接翻译成指令
# 这些针对汇编程序本身的指令,由于是有汇编程序处理,实际上并不会由计算机运行,
# 因此被称为汇编指令或伪操作

# .section .data 命令是数据段的开始。
# 数据段中要罗列出程序数据所需要的所有n内存存储空间
# 由于本程序没有使用任何数据,所以不需要这个段
.section .data

# .section .text是文本段的开始,存放指令的部分
.section .text

# .global _start  _start是一个符号,在汇编或链接过程中被替换,
# 符号一般用来标记程序或数据的位置,所以你可以用名字而非内存编号指代它们
# .global表示汇编程序不应该在汇编之后废弃此符号,因为链接器需要他
.global _start

# _start 定义_start标签的值,标签是一个符号,后面跟一个冒号:,
# 当汇编程序对程序进行汇编时,必须对每个数值和每条指令分配地址,
# 标签告诉汇编程序以该符号的值作为下一条指令或下一个数据元素的位置
# 这样如果数据或指令的实际位置更改,就无需重写其引用,因为符号会重新获取值
_start:
# movl指令将数字1移入%eax,数字1前面的的美元符号$表示我们要用立即寻址方式寻址
# 如果没有美元符号,指令将会进行直接寻址,加载地址1中的数字
# 我们希望加载实际数字1,所以必须使用立即寻址方式
# 将数字1移入%eax是因为我们准备调用Linux内核,数字1表示系统调用exit
movl $1,%eax
# 在进行系统调用的情况下,需要将状态码加载到%ebx,稍后返回给系统
# 加载这些数字本身不会做任何事情。系统调用之外的各类事务也要用到寄存器.
# 他们是执行加、减、比较等所有程序逻辑的地方,Linux只需要在系统调用前把
# 某些参数值加载到某些寄存器.通常,我们需要加载调用号到%eax,对于其他寄存器,
# 每个调用有不同要求
movl $0,%ebx
# int代表中断,0x80是要用到的中断号.中断会中断正常的程序流,把程序控制权从我们
# 的程序移到Linux,因此将进行一个系统调用
int  $0x80
